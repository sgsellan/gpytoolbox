From 2c9c29800296c220f70296196790bffcca27b387 Mon Sep 17 00:00:00 2001
From: Oded Stein <oded.stein.graphics@gmail.com>
Date: Thu, 13 Jul 2023 10:11:05 -0500
Subject: [PATCH 1/2] superfluous print statement

---
 src/gpytoolbox/sdf_flow.py | 2 --
 test/test_sdf_flow.py      | 2 +-
 2 files changed, 1 insertion(+), 3 deletions(-)

diff --git a/src/gpytoolbox/sdf_flow.py b/src/gpytoolbox/sdf_flow.py
index bac515e..34a2355 100644
--- a/src/gpytoolbox/sdf_flow.py
+++ b/src/gpytoolbox/sdf_flow.py
@@ -410,8 +410,6 @@ def sdf_flow_iteration(state,
     else:
         state.V = sp.sparse.linalg.spsolve(Q,b)
 
-    print(f"VpN: {np.linalg.norm(state.V)}")
-
     # catching flow singularities so we fail gracefully
     if np.any((np.isnan(state.V))):
         if verbose:
diff --git a/test/test_sdf_flow.py b/test/test_sdf_flow.py
index 2231a51..4672e2f 100644
--- a/test/test_sdf_flow.py
+++ b/test/test_sdf_flow.py
@@ -21,7 +21,7 @@ class TestRFTS(unittest.TestCase):
                 V_mc, F_mc = gpy.marching_cubes(sdf(GV), GV, n+1, n+1, n+1)
                 h_mc = gpy.approximate_hausdorff_distance(V_mc, F_mc.astype(np.int32), v, f.astype(np.int32), use_cpp = True)
                 V0, F0 = gpy.icosphere(2)
-                U,G = gpy.sdf_flow(GV, sdf, V0, F0, verbose=False, visualize=True, min_h = 2.0/n)
+                U,G = gpy.sdf_flow(GV, sdf, V0, F0, verbose=False, visualize=False, min_h = 2.0/n)
                 h_ours = gpy.approximate_hausdorff_distance(U, G.astype(np.int32), v, f.astype(np.int32), use_cpp = True)
                 # print("Hausdorff distance between mesh and marching cubes: ", h_mc)
                 # print("Hausdorff distance between mesh and our method: ", h_ours)
-- 
2.39.2 (Apple Git-143)


From 4ad4eacef7df5eaa135a4bc79ebb78f8bd6a8068 Mon Sep 17 00:00:00 2001
From: Oded Stein <oded.stein.graphics@gmail.com>
Date: Thu, 13 Jul 2023 10:29:12 -0500
Subject: [PATCH 2/2] batching

---
 src/gpytoolbox/sdf_flow.py | 21 +++++++++++----------
 1 file changed, 11 insertions(+), 10 deletions(-)

diff --git a/src/gpytoolbox/sdf_flow.py b/src/gpytoolbox/sdf_flow.py
index 34a2355..c8d8ee8 100644
--- a/src/gpytoolbox/sdf_flow.py
+++ b/src/gpytoolbox/sdf_flow.py
@@ -43,8 +43,13 @@ def sdf_flow(U, sdf, V, F, S=None,
         h=h, min_h=min_h)
     converged = False
 
-    # TODO: Replace this function with a simple while loop that breaks if converged.
+    # Little hack to pass max_iter, which is not keps as state.
+    # Set to the same default as in sdf_flow_iteration.
     dim = V.shape[1]
+    pass_max_iter = (10000 if dim==2 else 20000
+        ) if max_iter is None else max_iter
+
+    # TODO: Replace this function with a simple while loop that breaks if converged.
     def run_flow_iteration():
         nonlocal state, converged
         if not converged:
@@ -65,10 +70,6 @@ def sdf_flow(U, sdf, V, F, S=None,
 
             # TODO: remove callback code
             if callback is not None:
-                # Little hack to pass max_iter, which is not keps as state.
-                # Set to the same default as in sdf_flow_iteration.
-                pass_max_iter = (10000 if dim==2 else 20000
-                    ) if max_iter is None else max_iter
                 callback({'V':state.V, 'F':state.F,
                     'V_active':state.V_active,
                     'F_active':state.F_active,
@@ -148,7 +149,7 @@ def sdf_flow(U, sdf, V, F, S=None,
     else:
         if visualize:
             import matplotlib.pyplot as plt
-        while state.its is None or (state.its<max_iter and (not converged)):
+        while state.its is None or (state.its<pass_max_iter and (not converged)):
             run_flow_iteration()
 
     if return_U:
@@ -340,11 +341,11 @@ def sdf_flow_iteration(state,
     #Algorithm
     if batch_size>0 and batch_size<state.U.shape[0]:
         inds = state.rng.choice(state.U.shape[0], batch_size, replace=False)
-        state.U_batch = U[inds,:]
-        state.S_batch = S[inds]
+        state.U_batch = state.U[inds,:]
+        state.S_batch = state.S[inds]
         # include all inside points
-        state.U_batch = np.concatenate((state.U_batch, U[state.S>0,:]), axis=0)
-        state.S_batch = np.concatenate((state.S_batch, S[state.S>0]), axis=0)
+        state.U_batch = np.concatenate((state.U_batch, state.U[state.S>0,:]), axis=0)
+        state.S_batch = np.concatenate((state.S_batch, state.S[state.S>0]), axis=0)
     d2, I, b = squared_distance(state.U_batch, state.V, state.F,
         use_cpp=True, use_aabb=True)
     d = np.sqrt(d2)
-- 
2.39.2 (Apple Git-143)

